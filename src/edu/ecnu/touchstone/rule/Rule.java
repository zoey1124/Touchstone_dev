package edu.ecnu.touchstone.rule;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import edu.ecnu.touchstone.extractor.Query;
import edu.ecnu.touchstone.run.Touchstone;
import net.sf.jsqlparser.expression.*;
import net.sf.jsqlparser.expression.operators.relational.*;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.select.*;

public class Rule {
    private Logger logger = null;

    public Rule() {
        logger = Logger.getLogger(Touchstone.class);
    }

    public static List<Rule> NQcase(SelectBody selectBody) {
        List<Rule> rules = new ArrayList<>();
        // set operations
        if (selectBody instanceof SetOperationList) {

        }
        else if (selectBody instanceof PlainSelect) {
            PlainSelect plainSelect = (PlainSelect) selectBody;
            // select
            List<SelectItem> selectItems = plainSelect.getSelectItems();
            for (SelectItem selectItem: selectItems) {
                if (selectItem.toString().contains("select")) {

                }
            }
            // from
            FromItem from = plainSelect.getFromItem();
            if (from instanceof SubSelect) {
                rules.add(new FromRule());
            }
            // where
            Expression where = plainSelect.getWhere();
            if (where != null && where.toString().contains("select")) {
                where.accept(new ExpressionVisitorAdapter() {
                    @Override 
                    public void visit(InExpression inExpression) {
                        if (inExpression.toString().contains("select")) {
                            if (inExpression.isNot()) {
                                rules.add(new NotInRule());
                            } else {
                                rules.add(new InRule());
                            }
                        }
                    }
                    @Override
                    public void visit(ExistsExpression existExpression) {
                        if (existExpression.toString().contains("select")) {
                            if (existExpression.isNot()) {
                                rules.add(new NotExistRule());
                            } else {
                                rules.add(new ExistRule());
                            }

                        }
                    }
                });
            }
            // having
            Expression having = plainSelect.getHaving();
            if (having != null) {

            }
        } else if (selectBody instanceof WithItem) {

        } else {

        }
        return rules;
    }

    /* 
     * @Input: a flat Select query (e.g., no WITH ..., CREATE ...)
     * @Output: a list of ConstraintChain generated by this query 
     */
    public List<Object> parse(Query query) {
        Statement stmt = query.getStmt();
        Select select = (Select) stmt;
        SelectBody selectBody = select.getSelectBody();
        PlainSelect plainSelect = (PlainSelect) selectBody;
        List<Object> ret = new ArrayList<>();
        // where 
        Expression where = plainSelect.getWhere();
        if (where != null) {
            ret.addAll(parseExpression(where));
        }
        // join
        List<Join> joinList = plainSelect.getJoins();
        if (joinList != null) {
            for (Join join: joinList) {
                List<Expression> onExprs = (List<Expression>) join.getOnExpressions();  
                for (Expression onExpr: onExprs) {
                    List<Object> conditions = parseExpression(onExpr);
                    ret.addAll(conditions);
                }
            }
        }
        //having
        Expression having = plainSelect.getHaving();
        if (having != null) {
            List<Object> conditions = parseExpression(having);
            ret.addAll(conditions);
        }
        return ret;
    }

    /*
     * @Input: Expression
     * @Description: parse all conditions in where
     * @Return: FilterOperations and JoinInformations
     */
    public List<Object> parseExpression(Expression expr) {
        List<Object> operations = new ArrayList<>();
        expr.accept(new ExpressionVisitorAdapter() {


            @Override 
            public void visit(InExpression inExpression) {
                String operator = (inExpression.isNot()) ? "not in" : "in";
                FilterOperation filterOp = new FilterOperation(inExpression, operator);
                operations.add(filterOp);
            }

            @Override 
            public void visit(LikeExpression likeExpression) {
                String operator = (likeExpression.isNot()) ? "not like" : "like";
                FilterOperation filterOp = new FilterOperation(likeExpression, operator);
                operations.add(filterOp);
            }

            @Override 
            public void visit(NotEqualsTo notEqualsTo) {
                FilterOperation filterOp = new FilterOperation(notEqualsTo, "<>");
                operations.add(filterOp);
            }

            @Override
            public void visit(EqualsTo equalsTo) {
                if (isJoinCondition(equalsTo)) {
                    JoinInfo joinInfo = new JoinInfo(equalsTo);
                    operations.add(joinInfo);
                } else {
                    FilterOperation filterOp = new FilterOperation(equalsTo, "=");
                    operations.add(filterOp);
                }
            }

            @Override 
            public void visit(GreaterThan greaterThan) {
                FilterOperation filterOp = new FilterOperation(greaterThan, ">");
                operations.add(filterOp);
            }

            @Override 
            public void visit(GreaterThanEquals greaterThanEquals) {
                FilterOperation filterOp = new FilterOperation(greaterThanEquals, ">=");
                operations.add(filterOp);
            }

            @Override
            public void visit(MinorThan minorThan) {
                FilterOperation filterOp = new FilterOperation(minorThan, "<");
                operations.add(filterOp);
            }

            @Override 
            public void visit(MinorThanEquals minorThanEquals) {
                FilterOperation filterOp = new FilterOperation(minorThanEquals, "<=");
                operations.add(filterOp);
            }
        });
        logger.info("\n Query Filter Operations are: [\n" + operations + "\n]");
        return operations;
    }

    /*
     * @Input: BinaryExpression like a = b, a >= b
     */
    public boolean isJoinCondition(BinaryExpression expr) {
        Expression left = expr.getLeftExpression();
        Expression right = expr.getRightExpression();
        return (left instanceof Column) && (right instanceof Column);
    }

    public static void main(String[] args) {
        String sql = "select * from r join s on r.k1 = s.k2 join t on s.k3 = t.k4 where col in (1, 2, 3);";
        PropertyConfigurator.configure(".//test//lib//log4j.properties");
        try {
            Statement stmt = CCJSqlParserUtil.parse(sql);
            Select select = (Select) stmt;
            PlainSelect plainSelect = (PlainSelect) select.getSelectBody();
            Expression expr = plainSelect.getWhere();
            expr.accept(new ExpressionVisitorAdapter() {
                @Override
                public void visit(InExpression inExpr) {
                    System.out.println(inExpr);
                    System.out.println(inExpr.getLeftExpression());
                    System.out.println(inExpr.getRightItemsList());
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

class FilterOperation {
    String expression = null;
    String operator = null;
    String table = null;

    FilterOperation(InExpression expr, String operator) {
        Expression left = expr.getLeftExpression();
        ItemsList right = expr.getRightItemsList();
        Column leftColumn = (Column) left;
        if (leftColumn.getTable() != null) {
            this.table = leftColumn.getTable().getName();
        }
        String columnName = leftColumn.getColumnName();
        if (!right.toString().contains("$")) {
            operator += right.toString();
        }
        this.operator = operator;
        this.expression = columnName;
    }

    FilterOperation(BinaryExpression expr, String operator) {
        Expression left = expr.getLeftExpression();
        Expression right = expr.getRightExpression();
        Column leftColumn = (Column) left;
        if (leftColumn.getTable() != null) {
            this.table = leftColumn.getTable().getName();
        }
        String columnName = leftColumn.getColumnName();
        if (!right.toString().contains("$")) {
            operator += right.toString();
        }
        this.operator = operator;
        this.expression = columnName;
    }

    public void setTable(String table) {
        this.table = table;
    }
    public String getTable() {
        return this.table;
    }

    @Override
    public String toString() {
        return this.expression + "@" + this.operator;
    }
}

class JoinInfo {
    String pkTable = null;
    String fkTable = null;
    String pk = null;
    String fk = null;

    // expr left and right should both be column type, and op should be =
    public JoinInfo(BinaryExpression expr) {
        Column left = (Column) expr.getLeftExpression();
        Column right = (Column) expr.getRightExpression();
        pk = left.getColumnName();
        fk = right.getColumnName();
        if (left.getTable() != null) {
            this.pkTable = left.getTable().getName();
        } else {

        }
        if (right.getTable() != null) {
            this.fkTable = right.getTable().getName();
        } else {

        }
    }

    @Override
    public String toString() {
        return "JoinInfo = pk:" + this.pk + ", fk:" + this.fk; 
    }
}
